#include "main.h"
#include "cmsis_os.h"

/* Define servo motor positions */
#define SERVO_MIN_ANGLE 0 // Minimum angle supported by servo (in degrees)
#define SERVO_MAX_ANGLE 180 // Maximum angle supported by servo (in degrees)
#define SERVO_MIN_DUTY_CYCLE 1000 // Example minimum duty cycle for servo
#define SERVO_MAX_DUTY_CYCLE 2000 // Example maximum duty cycle for servo

/* Global variables to hold current angle for servo */
uint16_t servo_angle = 0;
uint16_t received_angle = 0;

/* Task function prototypes */
void Task_Servo(void *argument);
void Task_Communication(void *argument);
void Task_Compare(void *argument);

/* Task handles */
osThreadId_t ServoTaskHandle;
osThreadId_t CommunicationTaskHandle;
osThreadId_t CompareTaskHandle;

/* Task attributes */
const osThreadAttr_t Task_attributes = {
  .name = "Task",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

/* Queue handle */
osMessageQueueId_t QueueHandle;

/* TIM handler declaration */
TIM_HandleTypeDef htim2;

int main(void)
{
  /* Initialize HAL, system clock, and peripherals */
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_TIM2_Init();

  /* Create queue */
  QueueHandle = osMessageQueueNew(1, sizeof(uint16_t), NULL);

  /* Initialize scheduler */
  osKernelInitialize();

  /* Create tasks */
  ServoTaskHandle = osThreadNew(Task_Servo, NULL, &Task_attributes);
  CommunicationTaskHandle = osThreadNew(Task_Communication, NULL, &Task_attributes);
  CompareTaskHandle = osThreadNew(Task_Compare, NULL, &Task_attributes);

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */
  while (1) {}
}

/* Task function for controlling servo motor */
void Task_Servo(void *argument)
{
	while (1)
	  {
	    // Calculate duty cycle based on servo angle
	    uint16_t duty_cycle = SERVO_MIN_DUTY_CYCLE +
	                          ((servo_angle - SERVO_MIN_ANGLE) *
	                          (SERVO_MAX_DUTY_CYCLE - SERVO_MIN_DUTY_CYCLE)) /
	                          (SERVO_MAX_ANGLE - SERVO_MIN_ANGLE);

	    // Set PWM duty cycle for servo motor
	    TIM_OC_InitTypeDef sConfigOC;
	    sConfigOC.OCMode = TIM_OCMODE_PWM1;
	    sConfigOC.Pulse = duty_cycle;
	    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
	    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
	    HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
	    HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);

	    osDelay(20); // Adjust delay as needed
	  }

}

/* Task function for communication */
void Task_Communication(void *argument)
{
  while (1)
  {

    received_angle = 90; // Example angle received from STM32

    // Send received angle to servo task
    osMessageQueuePut(QueueHandle, &received_angle, 0, osWaitForever);

    // Delay before next communication (adjust as needed)
    osDelay(1000);
  }
}

/* Task function for comparing servo angle with communication task's value */
void Task_Compare(void *argument)
{
  while (1)
  {
    // Check if servo angle matches the received angle
    if (servo_angle != received_angle)
    {
      // Update servo angle to received angle
      servo_angle = received_angle;
    }

    // Delay before next comparison (adjust as needed)
    osDelay(100);
  }
}

/* TIM2 init function */
void MX_TIM2_Init(void)
{
  // TIM2 initialization code generated by STM32CubeMX
}

/* GPIO init function */
void MX_GPIO_Init(void)
{
  // GPIO initialization code generated by STM32CubeMX
}

/* System Clock Configuration */
void SystemClock_Config(void)
{
  // System Clock configuration code generated by STM32CubeMX
}

/* Error_Handler function */
void Error_Handler(void)
{
  // Error handler code
}
